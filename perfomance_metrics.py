# -*- coding: utf-8 -*-
"""perfomance_metrics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JCyI8s5ag7pOC6DsL5cb6iLtC7yKTie1
"""

import numpy as np

def extract_tf(S):
  # Length of the signal array
  signal_length = len(S)

  # Time duration of each time step
  time_step_duration = 400 / signal_length  # Assuming the signal lasts for 400 ms

  # Initialize an empty list to store time moments where impulses exist
  impulse_time_moments = []

  for i in range(signal_length):
    if S[i] == 1:
        time_moment = i * time_step_duration
        impulse_time_moments.append(time_moment)

  return np.array(impulse_time_moments)

# Performance index
'''here the main function is Pm with args
   tfl_l, tfd_l, t_l: t_l is list/array
   of every time step from zero 400 ms;
   tfl_l and tfl_d are lists/arrays of
   particular time steps at which
   there is a spike in spike train of
   output before the training S^l(t) and
   desired output after training S^d(t)
'''
def Hevi_func(t, tf):
  if t < tf:
    return 0
  else:
    return 1

def exp(t,tf):
  tau = 1
  return np.exp((-t+tf)/tau)

def L_S(t_l, tf_l):
  L_S = []
  for t in t_l:
    sum = 0
    for tf in tf_l:
      H = Hevi_func(t, tf)
      sum += exp(t,tf) * H
    L_S.append(sum)
  return L_S

def Pm(Sl, Sd, t_l):
  tfl_l = extract_tf(Sl)
  tfd_l = extract_tf(Sd)
  L_Sl = L_S(t_l, tfl_l)
  L_Sd = L_S(t_l, tfd_l)

  L_Sd_arr = np.array(L_Sd)
  L_Sl_arr = np.array(L_Sl)


  abs_diff = np.abs(L_Sd_arr - L_Sl_arr)

  return np.trapz(abs_diff)

#Precision
'''in this function firstly we calculate
   minimal inter-spike interval in S^d(t)
   to define parameter r. Then check two
   conditions of approximation with this
   parameter
'''
def precision_calc(Sl_hat, Sd):
  tfl_l_hat = extract_tf(Sl_hat)
  tfd_l = extract_tf(Sd)
  min = 500
  for i in range(tfd_l.shape[0]-1):
    if np.abs(tfd_l[i] - tfd_l[i+1]) < min:
      min = np.abs(tfd_l[i] - tfd_l[i+1])

  r = round(min/2, 2)

  if tfl_l_hat.shape[0] == tfd_l.shape[0]:
    for tfd in tfd_l:
      tfd_array = np.ones_like(tfl_l_hat) * tfd
      abs_diff = np.abs(tfd_array - tfl_l_hat)
      if np.count_nonzero(abs_diff <= r) != 1:
        return f'S^l_hat(t) does not approximate S^d(t) with the precision r = {r}'
      else:
        return f'S^l_hat(t) approximates S^d(t) with the precision r = {r}'

#Spike-shift error e(t)
'''in this function we calculate time
   difference between td and the nearest
   spike in tl_f. Finally this function
   returns a list of pairs (td,(f),âˆ†t(f))
'''

def error(Sl_hat, Sd):
  tfl_l_hat = extract_tf(Sl_hat)
  tfd_l = extract_tf(Sd)
  e = []
  for td in tfd_l:
    nearest_spike_time = min(tfl_l_hat, key=lambda x: abs(x - td))
    delta_t = abs(td - nearest_spike_time)
    e.append((td, delta_t))

  return e
